rubrique .bss
    entrée RESB 4

section .données

section .texte
    global_start
    _commencer :
        déplacer eax,3 ; 3 = lire
        mov ebx,0 ; standard
	mov ecx, entrée
	mov edx, 4;Longueur maximale de saisie
	int 0x80 ;0x80 est une fonction
	xor edx, edx
	mov esi, entrée
    
    conversion :
	
	mov bl, [esi] ;stockage sasi utilisateur dans bl
	cmp bl, 0 ;on compare a 0 pour savoir si on a finit
	je teste ; sauter un test si oui
	cmp bx, 0x0A ;comparaison de si il ya un 0x0A (saut de ligne)
	je teste; si oui Sauter un test
	
	sub bl, 48 ;Table caractère ASCII -> nombre
	imul edx, 10 ;
	ajouter edx, ebx ;
	inc esi ; caractère suivant (se lit dans l'autre sens en ASM)
	conversion jmp ;Répète en jumpant au début de la boucle
      
    test:
	
	déplacer eax, edx ; eax prend la valeur de edx
	xou edx, edx ; edx est initialisé à 0
        mov ebx, 2 ; ebx prend 2
	idiv ebx ; diviser eax par ebx le reste sera dans edx
	cmpedx, 0 ; si le reste = a 0 alors
	je paire; sauter une paire
	xor edx, edx
	déplacer eax, 1 ; sinon eax = 1 écriture
	mov ebx, 1 ; ebx = 1
	entier 0x80 ; renvoi 1

    paire :
	déplacer eax, 1 ; eax = 1 écriture
	mov ebx, 0; ebx = 0
	entier 0x80 ; renvoi 0
